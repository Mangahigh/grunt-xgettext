/*
 * grunt-xgettext
 * https://github.com/arendjr/grunt-xgettext
 *
 * Copyright (c) 2013-2014 Arend van Beelen, Speakap BV
 * Licensed under the MIT license.
 */

"use strict";

const _ = require('lodash');

module.exports = grunt => {

    const escapeString = string => '"' + string.replace(/\n/gm, "\\n").replace(/"/g, '\\"') + '"';

    const mergeMessages = (a, b) => {
        for(let index in b) {
            if (b.hasOwnProperty(index)) {
                if (a[index]) {
                    let location = a[index].location;

                    if (location) {
                        if (a[index].location) {
                            a[index].location = [b[index].location, location].join('\n');
                        } else {
                            a[index].location = location;
                        }
                    }
                } else {
                    a[index] = b[index];
                }
            }
        }

        return a;
    };

    grunt.registerMultiTask('xgettext', `Extracts translatable messages`, function() {

        const options = this.options({
            functionName: 'tr',
            potFile: 'messages.pot',
            processMessage: _.identity,
            header: undefined
        });

        const translations = {};

        this.files.forEach(f => {
            const extractor = require(`./extractors/${f.dest}`);

            const messages = {};
            f.src.forEach(file => {
                mergeMessages(messages, extractor(file, options));
            });

            mergeMessages(translations, messages);

            const count = _.keys(messages).length;
            grunt.log.writeln(`Extracted ${count} messages from ${f.dest} files.`);
        });

        let contents = `# Generated by grunt-xgettext on ${(new Date()).toString()}` + '\n\n';

        if (options.header) {
            contents += 'msgid ""\n';
            contents += 'msgstr ""\n';

            for (let i = 0; i < options.header.length; i++) {
                contents += options.header[i] + '\n';
            }

            contents += '\n';
        }

        contents += _.map(translations, definition => {
            let buffer = '';
            if (definition.location) {
                buffer += _.map(definition.location.split('\n'), locationLine => `#: ${locationLine}` + '\n').join('');
            }

            if (definition.comment) {
                buffer += _.map(definition.comment.split('\n'), commentLine => `#. ${commentLine}` + '\n').join('');
            }
            if (definition.context) {
                buffer += `msgctxt ${escapeString(definition.context)}` + '\n';
            }
            buffer += `msgid ${escapeString(definition.singular)}` + '\n';
            if (definition.plural) {
                buffer += `msgid_plural ${escapeString(definition.plural)}` + '\n';
                buffer += `msgstr[0] ${escapeString(definition.message)}` + '\n';
            } else {
                buffer += `msgstr ${escapeString(definition.message)}` + '\n';
            }
            return buffer;
        }).join('\n');

        grunt.file.write(options.potFile, contents);

        const count = _.keys(translations).length;
        grunt.log.writeln(`${count} messages successfully extracted, ${options.potFile} written.`);

    });

};
